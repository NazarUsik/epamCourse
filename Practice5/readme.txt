Практическое занятие №5
_______________________

Замечания.

(1) В Jenkins время сборки проекта ограничено 2 (двумя) минутами. По истечение этого времени задача будет снята с выполнения.

Console Output
-------------------------------------------------------
Build timed out (after 2 minutes). Marking the build as aborted.
Build was aborted
Finished: ABORTED
-------------------------------------------------------

(2) В корневом пакете должен находится класс Demo, который демонстрирует функциональность всех подзадач (его будет вызывать Jenkins).

(3) Для решения каждой подзадачи X будет гарантированно использованно несколько потоков:
  * поток, который выполняет метод PartX.main (это тот же самый поток, который выполняет Demo.main);
  * некоторое количество дочерних потоков.
Завершайте выполнение дочерних потоков ДО ТОГО, как будет завершен метод PartX.main (это нужно для тестов, который запускает Jenkins).

_______________________

Задание 1
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part1
-------------------------------------------------------

Создать дочерний поток, который бы в течение примерно 1 сек печатал свое имя каждые треть секунды.
Сделать это тремя способами:
  * при помощи расширения класса Thread;
  * при помощи реализации интерфейса Runnable.
  * с использованием ссылки на статический метод, который реализует заданную функциональность.
  
Продемонстрировать работу всех трех вариантов. Выполнение должно быть последовательным.
Вначале отрабатывает одна реализация, потом вторая, затем третья.

_______________________

Задание 2
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Spam
-------------------------------------------------------

Создать класс Spam, который получает в конструкторе массив сообщений и согласованный с ним массив интервалов времени в миллисекундах и выводит одновременно соответствующие сообщения на экран через заданные интервалы времени. По нажатию на Enter приложение должно завершать свою работу (данную функциональность поместить в метод Spam.main).

Рекомендуемая структура класса Spam:
-------------------------------------------------------
public class Spam {
	private Thread[] threads;
	public Spam(String[], int[]) {...}
	public void start() {...}
	public void stop() {...}
	private static class Worker extends Thread {...}
	public static void main(String[] args) {...}
-------------------------------------------------------

Входные данные (массив сообщений и массив пауз) записывать в коде класса Spam. Количество элементов в каждом из массивов - минимум 2, их можно взять из примера (см. код ниже).

Пример входной информации:
-------------------------------------------------------
String[] messages = new String[] { "@@@", "bbbbbbb" };
int[] times = new int[] { 333, 222 };
-------------------------------------------------------

В методе Part2.main смоделировать ввод Enter через 2 сек.

Алгоритм моделирования консольного ввода (метод Part2.main):
-------------------------------------------------------
a) подменить системный поток ввода на свой собственный
   System.setIn(YOUR_OWN_INPUT_STREAM);
 
b) в отдельном потоке вызвать Spam.main
   Thread t = new Thread() { public void run() {Spam.main(null);}};
   t.start();
 
c) дождаться завершения Spam.main
   t.join();
 
d) восстановить системный поток
   System.setIn(CAСHED_VALUE_OF_SYSTEM_IN)
-------------------------------------------------------

(4) Для реализации своего собственного потока ввода целесообразно создать класс, который расширяет абстрактный класс java.io.InputStream. При этом придется реализовать единственный абстрактный метод этого класса:

-------------------------------------------------------
public abstract int read() throws IOException;
-------------------------------------------------------

Все методы класса InputStream (а также всех его наследников), которые читают байты из источника информации, в конечном счете вызывают метод read. Достаточно реализовать паузу в этом методе при первом его вызове, которая заставит поток выполнения, который вызвал метод read, ожидать. Метод read должен последовательно возвращать байты, которые соответствуют ограничителю строки, после чего постоянно возвращать -1 (признак того, что информации во входном потоке больше нет).

_______________________

Задание 3
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part3
-------------------------------------------------------

Создать класс со следующим содержимым:
-------------------------------------------------------
public class Part3 {
	private int counter;
	private int counter2;
	
	private Thread[] threads;
	...
	
	public Part3(int n, int k, int t) { ...	}
	
	public void reset() { ... }	
	public void test() { ... }
	public void testSync() { ... }	
	
	public static void main(String[] args) {
		Part3 p = new Part3(3, 5, 100);
		p.test();
		p.reset();
		p.testSync();
	}	
}
-------------------------------------------------------

Метод test запускает на выполнение n дочерних потоков, каждый из которых в цикле повторяет k раз следующее:
  * печатает значения счетчиков counter и counter2 через пробел;
  * увеличивает первый счетчик counter на единицу;
  * засыпает на t мсек;
  * увеличивает второй счетчик counter2 на единицу.

Метод testSync делает то же самое, что и test, но содержимое цикла подвергнуто синхронизации.

Реализовать следующую схему (см. метод Part3.main):
  * отрабатывает не синхронизированный вариант (test);
  * отрабатывает синхронизированный вариант (testSync).

Замечания.
1) перед тем, как начнет работу синхронизированный вариант, сборосьте значения счетчиков в 0 (reset);
2) для вывода в стандартный поток вывода используйте метод PrintStream#printf:
-------------------------------------------------------
System.out.printf("%s %s%n", counter, counter2);
-------------------------------------------------------

_______________________

Задание 4
-------------------------------------------------------
Название класса: ua.nure.your_last_name.Practice5.Part4
Входную информацию загружать из файла part4.txt
-------------------------------------------------------

Распараллелить задачу поиска максимального значения в матрице целых чисел MxN (загружать из файла) при помощи M потоков. Дополнительно решить задачу поиска максимального значения без распараллеливания. Вывести результат и время выполнения кода (в миллисекундах) для обоих вариантов.
	
В обязательном порядке в обоих вариантах каждую операцию сравнения снабдить задержкой в 1 мс!

Придерживаться следующего формата вывода:
-------------------------------------------------------
MAX
TIME
MAX2
TIME2
-------------------------------------------------------

где MAX, TIME - максимальное значение и время поиска при многопоточном решении задачи; MAX2, TIME2 - максимальное значение и время поиска в однопоточном варианте.
	
Работу приложения проверить на матрице 4x100 случайных чисел.

Содержимое файла part4.txt должно представлять из себя читабельную матрицу, числа разделены пробелами, строки разделены ограничителем строки.

Замечания.

(1) Ограничитель строки должен быть платформонезависимым (учитывать это при чтении информации).

(2) Входной файл part4.txt создать любым удобным для вас способом до запуска Part4.main (например, с помощью какого-нибудь вспомогательного класса). Приложение (Part4.main) файл part4.txt не создает и содержимое его не модифицирует, размерность матрицы определять по содержимому part4.txt

Пример содержимого part4.txt для M=5, N=20
-------------------------------------------------------
706 575 855 882 595 778 477 602 147 467 693 793 120 384 256 866 548 367 910 848
206 232 632 315 743 823 620 111 279 548 210 393 791 815 519 768 168 484 780 705
709 127 900 171 189 590 563 317 600 975 892 296 166 353 863 312 399 872 964 591
302 869 679 157 419 485 325 290 739 149 407 648 688 474 311 177 318 611 348 557
559 283 171 352 698 759 384 822 598 410 802 293 962 859 812 153 436 392 869 167
-------------------------------------------------------

Пример вывода результата
-------------------------------------------------------
975
26
975
115
-------------------------------------------------------
	
Для входных данны3 M=4, N=100 время распараллеленного поиска должно быть примерно в 4 раза меньше, чем время поиска в однопоточном варианте.

_______________________

Задание 5
-------------------------------------------------------
Название класса: ua.nure.your_last_name.Practice5.Part5
Выходную информацию записывать в файл part5.txt
-------------------------------------------------------

Создать k потоков, которые одновременно пишут в один и тот же файл символы:

-------------------------------------------------------
первый поток записывает цифру 0 ровно 20 раз на 1й строке файла;
второй поток записывает цифру 1 ровно 20 раз на 2й строке файла;
...
десятый поток записывает цифру 9 ровно 20 раз на 10й строке файла.
-------------------------------------------------------

Требования к реализации.
(1) В обязательном порядке запись каждой цифры снабдить паузой в 1 мс!
(2) Для записи использовать класс RandomAccessFile.
(3) Допускается использование не более одного объекта класса RandomAccessFile!
(4) Перед началом работы файл в который будет происходить запись должен быть удален, если он существует.
(5) Главный поток, после запуска дочерних потоков на выполнение, должен дождаться их завершения, после чего вывести в консоль содержимое файла.

Замечания.
(1) Метод RandomAccessFile#seek(long) позволяет передвигать указатель внутри файла. Каждый поток должен знать в каком месте файла ему записывать информацию. Так как в условии фигурирует термин "строка", следует вывод каждого потока завершать ограничителем строки, который выводить кросс-платформенным образом.
(2) Для того, чтобы записать некоторую цифру можно использовать выражение '0'+ n, где n - цифра от 0 до 9 включительно.
Передвижение указателя внутри файла и запись информации необходимо синхронизировать.

Результат работы приложения
-------------------------------------------------------
00000000000000000000
11111111111111111111
22222222222222222222
33333333333333333333
44444444444444444444
55555555555555555555
66666666666666666666
77777777777777777777
88888888888888888888
99999999999999999999
-------------------------------------------------------

_______________________

Задание 6
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part6
-------------------------------------------------------

В главном потоке создать и запустить на выполнение дочерний поток.
Последовательно перевести и распечатать состояние дочернего потока (возможно через промежуточные состояния) в:
BLOCKED, WAITING, TERMINATED

Замечания.
1) метод Thread.sleep не использовать;
2) допускается использовать только один монитор синхронизации (см. код ниже).
3) многократный запуск приложения на выполнение должен генерировать один и тот же результат.
4) перед решение задачи целесообразно ознакомится с примером, кот. находится на GDocs диске по адресу:
Lectures/Module08/code/Lecture-2019-05-20.zip!/State/src/Test.java

Заглушка класса Part6:
-------------------------------------------------------
public class Part6 {

	private static final Object M = new Object();

	public static void main(String[] args) throws InterruptedException {
		Thread t = new Thread() {
			public void run() {
				// place your code here
			}
		};

		// place your code here
	}
}
-------------------------------------------------------

Результат выводимый в консоль:
-------------------------------------------------------
BLOCKED
WAITING
TERMINATED
-------------------------------------------------------