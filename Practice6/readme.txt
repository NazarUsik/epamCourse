Практическое задание №6
_______________________

Замечания.

(1) Везде в коде, при реализации функциональных интерфейсов использовать лямбда выражения или ссылки на методы.

(2) Помните, что контейнеры HashSet/ТгееSet не контролируют потенциальное появление дубликатов при изменении состояния объектов, которые в них хранятся, то же касается и ключей контейнеров HashMap/ТгееМар.

(3) В задании 6 под словом понимать непрерывную последовательность букв латинского алфавита.
_______________________


Задание 1
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part1
Классы:
Part1 - содержит моделирование консольного ввода/вывода и вызов метода WordContainer.main
WordContainer - содержит требуемую по условию функциональность
Word - поставлен в соответствие сущности 'слово с информацией о его частоте в тексте'.
-------------------------------------------------------

Разработать приложение, которое считывает текст из консольного ввода и выводит слова в порядке убывания частоты их появления в тексте (при совпадении частот порядок - лексикографичеcкий).
Под словами понимать непрерывную последовательность непробельных символов.

Решить задачу с применением ООП подхода.

Класс Word, содержит строковое поле content и целое поле frequency, контейнер WordContainer агрегирует объекты Word.

При использовании контейнерных классов из ядра грамотно реализовать (если они будут нужны) методы Word#equals / Word#hashCode / Word#compareTo.

При запуске WordContainer.main осуществляет чтение из стандартного потока ввода (консоли). Консольный ввод в общем случае может содержать несколько строк, в каждой строке может быть несколько слов. Признаком завершения консольного ввода служит слово stop.

Продемонстрировать работу приложения (Part1.main).

Пример входной информации
-------------------------------------------------------
asd 43 asdf asd 43
434 asdf
kasdf asdf stop asdf
stop
-------------------------------------------------------

Пример выходной информации
-------------------------------------------------------
asdf : 3
43 : 2
asd : 2
434 : 1
kasdf : 1
-------------------------------------------------------
_______________________


Задание 2
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part2
Название класса: Part2
-------------------------------------------------------

Написать программу, которая моделирует следующий процесс.

В кругу стоят n человек, пронумерованных от 0 до n-1.
При ведении счета по кругу вычеркивается каждый k-й человек (0<k<n), пока не останется один.

Пример для n=7 и k=3.
Начальное состояние:
0123456
Итерации:
013456
01346
0346
034	
03
3

Решить задачу двумя способами:

1) при помощи удаления элемента по индексу самим контейнером [List#remove(int)]
-------------------------------------------------------
// метод возвращает время работы
public static long removeByIndex(List<Integer> list, int k) {}
-------------------------------------------------------

2) при помощи удаления элемента с помощью итератора [Iterator#remove()]
-------------------------------------------------------
// метод возвращает время работы
public static long removeByIterator(List<Integer> list, int k) {}
-------------------------------------------------------

Сравнить время работы каждого способа на одинаковых входных данных (задавать в Part2.main) с использованием объектов ArrayList и LinkedList.
В качестве входных данных использовать n=10000, k=4.

Продемонстрировать работу приложения (Part2.main)

Пример выходной информации (придерживаться данного формата).
-------------------------------------------------------
ArrayList#Index: 13 ms
LinkedList#Index: 93 ms
ArrayList#Iterator: 20 ms
LinkedList#Iterator: 15 ms
-------------------------------------------------------
_______________________


Задание 3
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part3
Названия классов: Part3, Parking
-------------------------------------------------------

Реализовать класс Parking, моделирующий работу n-местной автостоянки.

Машина подъезжает к определенному месту k (0 <= k < n) и, если оно не занято, занимает его.
Если место k занято, то едет вправо, пока не встретит свободное место.
Если свободного места вплоть до конца стоянки нет, то поиск свободного места осуществляется с начала стоянки.
Если все места заняты, то состояние стоянки не меняется (машина уезжает).
Данную функциональность реализовать в методе:
-------------------------------------------------------
// Метод возвращает true, если машину удалось поставить на стоянку
boolean arrive(int k)
-------------------------------------------------------

Дополнительно реализовать метод, моделирующий отъезд машины:
-------------------------------------------------------
// Метод возвращает true, если в позиции k находилась машина
boolean depart(int k)
-------------------------------------------------------

Методы бросает исключение IllegalArgumentException, если k находится вне диапазона [0, n-1].

Также реализовать метод, который распечатывает текущее состояние стоянки:
-------------------------------------------------------
void print()
-------------------------------------------------------

Обозначать нулем пустое место; единицей - занятое место.

Пример для n=4.
Начальное состояние стоянки: 0000

Состояние стоянки после выполнения методов (справа после запятой значение, возвращаемое методами):
-------------------------------------------------------
parking.arrive(2)  // 0010, true
parking.arrive(3)  // 0011, true
parking.arrive(2)  // 1011, true
parking.arrive(2)  // 1111, true
parking.arrive(2)  // 1111, false
parking.depart(1)  // 1011, true
parking.depart(1)  // 1011, false
-------------------------------------------------------

Продемонстрировать работу приложения (Part3.main).
_______________________


Задание 4
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part4
Названия классов: Part4, Range
-------------------------------------------------------

Написать класс Range, который бы представлял собой промежуток чисел [n, m], где n < m.
Класс должен реализовывать интерфейс Iterable.
Итератор реализовать таким образом, чтобы он проходил он начала до конца промежутка.
В конструктор передавать дополнительный параметр reverse.

Класс Range должен иметь два конструктора:
-------------------------------------------------------
public Range(int n, int m) { ... }
public Range(int n, int m, boolean reverse) { ... }
-------------------------------------------------------

Пример:
-------------------------------------------------------
Range range = new Range(3, 10);
for (Integer el : range) {
	System.out.printf("%d ", el);
}
System.out.println();
// result: 3 4 5 6 7 8 9 10
 
range = new Range(3, 10, true);
for (Integer el : range) {
	System.out.printf("%d ", el);
}
System.out.println();
// result: 10 9 8 7 6 5 4 3
-------------------------------------------------------

Контейнерные классы не использовать.

Продемонстрировать работу приложения (Part4.main).
_______________________


Задание 5
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part5
Названия классов: Part5, Tree
-------------------------------------------------------

Создать generic класс Tree, который реализует структуру данных "двоичное дерево поиска".
Контейнерные классы не использовать.

Элементы класса Tree, обязательные к реализации:
-------------------------------------------------------
public class Tree<E extends Comparable<E>> {
	// добавляет элемент в контейнер
	// если в контейнере есть элемент равный по compareTo добавляемому,
	// то добавления не происходит и метод возвращает false
	// в противном случае элемент попадает в контейнер и метод возвращает true
	// первый добавляемый элемент становится корнем дерева
	// автобалансировки в дереве нет
	public boolean add(E element) {...}
 
	// добавляет все элементы из массива в контейнер (вызов в цикле метода add, см. выше)
	public void add(E[] elements) {...}
 
    // удаляет элемент из контейнера
	// если удаляемого элемента в контейнере нет, то возвращает false
	// в противном случае удаляет элемент и возвращает true
	// ВАЖНО! при удалении элемента дерево не должно потерять свойства бинарного дерева поиска
	public boolean remove(E element) {...}
 
	// распечатывает дерево, так чтобы было видно его древовидную структуру, см. ниже пример
	public void print() {...}
 
	// вложенный класс, объекты этого класса составляют дерево
	private static class Node<E> {...}
}
-------------------------------------------------------

Результат вывода Part5.main (отступ 2 пробела):
-------------------------------------------------------
true
false
~~~~~~~
    0
  1
    2
3
    4
  5
    6
~~~~~~~
true
false
~~~~~~~
    0
  1
    2
3
    4
  6  
-------------------------------------------------------

Продемонстрировать работу приложения (Part5.main).

При удалении элемента придерживаться следующего алгоритма.
1. Если у узла нет дочерних узлов, то у его родителя нужно заменить соответствующий указатель на null.
2. Если у узла есть только один дочерний узел, то нужно создать новую связь между родителем удаляемого узла и его дочерним узлом.
3. Если у узла два дочерних узла, то нужно 
3.1. найти следующий за ним элемент (у этого элемента не будет правого потомка)
3.2. его левого потомка подвесить на место найденного элемента
3.3. удаляемый узел заменить найденным узлом.

Визуальное изображение алгоритма (на картинке дерево "перевернуто"): algorithm.png
_______________________


Задание 6
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part6
Класс: Part6 (принимает параметры командной строки)
Входную информацию загружать из файла part6.txt (должен находится в корне проекта)
-------------------------------------------------------

Реализовать консольное приложение (Part6) которое анализирует текст.

Формат входных параметров командной строки для приложения (программа должна понимать как короткие, так и длинные опции):
-------------------------------------------------------
-i (или --input) путь к входному файлу;
-t (или --task) наименование подзадачи.
-------------------------------------------------------

Всего параметров командной строки 4, т.е. две пары <имя_опции значение_опции>.
Порядок следования опций с их значениями прооизвольный.

Примеры параметров командной строки для запуска приложения:
-------------------------------------------------------
-i input.txt -t frequency
--input input.txt --task length
-------------------------------------------------------

В методе Demo.main смоделировать передачу параметров командной строки в метод Part6.main:
-------------------------------------------------------
System.out.println("~~~~~~~~~~~~Part6");
Part6.main(new String[] {"--input", "part6.txt", "--task", "frequency"});
Part6.main(new String[] {"--input", "part6.txt", "--task", "length"});
Part6.main(new String[] {"--input", "part6.txt", "--task", "duplicates"});
-------------------------------------------------------

Подзадач всего три: frequency, length, duplicates.

Подзадача Part 1 (frequency)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.Part61
-------------------------------------------------------

Во входном файле найти три слова, которые встречаются наиболее часто (при совпадении частот – те, которые встречаются раньше), и распечатать их отсортированными по алфавиту в обратном порядке, в формате: слово ==> частота

Пример вывода:
-------------------------------------------------------
panda ==> 15
ezhik ==> 20
apple ==> 19
-------------------------------------------------------

Подзадача Part 2 (length)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.part6.Part62
-------------------------------------------------------

Во входном файле найти три самых длинных слова и распечатать их в формате: слово ==> количество букв в слове. Список должен быть отсортирован по убыванию количества букв в слове.

Если у двух слов количество букв совпадает, то слово, которое было в исходном файле раньше, должно в результирующем списке находиться также раньше.

Пример вывода:
-------------------------------------------------------
anesthetist ==> 11
kitchen ==> 7
bird ==> 4
-------------------------------------------------------

Подзадача Part 3 (duplicates)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.part6.Part63
-------------------------------------------------------

Во входном файле найти первые три слова, которые имеют дубликаты, и напечатать их инверсию в верхнем регистре.

Пример вывода
-------------------------------------------------------
ADNAP
TAC
ENIGREBUA
-------------------------------------------------------